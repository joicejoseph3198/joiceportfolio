{"ast":null,"code":"import _slicedToArray from\"H:/Web Dev/React Learning/web-1/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect}from\"react\";function useOnScreen(ref){var threshold=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0.3;// State and setter for storing whether element is visible\nvar _useState=useState(false),_useState2=_slicedToArray(_useState,2),isIntersecting=_useState2[0],setIntersecting=_useState2[1];useEffect(function(){var observer=new IntersectionObserver(function(_ref){var _entry$isIntersecting;var _ref2=_slicedToArray(_ref,1),entry=_ref2[0];// Update our state when observer callback fires\nsetIntersecting((_entry$isIntersecting=entry===null||entry===void 0?void 0:entry.isIntersecting)!==null&&_entry$isIntersecting!==void 0?_entry$isIntersecting:false);},{rootMargin:\"0px\",threshold:threshold});var currentRef=ref.current;if(currentRef){observer.observe(currentRef);}return function(){if(currentRef){observer.unobserve(currentRef);}};},[ref,threshold]);// Empty array ensures that effect is only run on mount and unmount\nreturn isIntersecting;}export default useOnScreen;","map":{"version":3,"sources":["H:/Web Dev/React Learning/web-1/src/components/hooks/useOnScreen.js"],"names":["useState","useEffect","useOnScreen","ref","threshold","isIntersecting","setIntersecting","observer","IntersectionObserver","entry","rootMargin","currentRef","current","observe","unobserve"],"mappings":"kHAAA,OAASA,QAAT,CAAmBC,SAAnB,KAAoC,OAApC,CAEA,QAASC,CAAAA,WAAT,CAAqBC,GAArB,CAA2C,IAAjBC,CAAAA,SAAiB,2DAAL,GAAK,CACzC;AACA,cAA0CJ,QAAQ,CAAC,KAAD,CAAlD,wCAAOK,cAAP,eAAuBC,eAAvB,eAEAL,SAAS,CAAC,UAAM,CACd,GAAMM,CAAAA,QAAQ,CAAG,GAAIC,CAAAA,oBAAJ,CACf,cAAa,4DAAXC,KAAW,UACX;AACAH,eAAe,wBAACG,KAAD,SAACA,KAAD,iBAACA,KAAK,CAAEJ,cAAR,+DAA0B,KAA1B,CAAf,CACD,CAJc,CAKf,CACEK,UAAU,CAAE,KADd,CAEEN,SAAS,CAATA,SAFF,CALe,CAAjB,CAUA,GAAMO,CAAAA,UAAU,CAAGR,GAAG,CAACS,OAAvB,CACA,GAAID,UAAJ,CAAgB,CACdJ,QAAQ,CAACM,OAAT,CAAiBF,UAAjB,EACD,CACD,MAAO,WAAM,CACX,GAAIA,UAAJ,CAAgB,CACdJ,QAAQ,CAACO,SAAT,CAAmBH,UAAnB,EACD,CACF,CAJD,CAKD,CApBQ,CAoBN,CAACR,GAAD,CAAMC,SAAN,CApBM,CAAT,CAoBsB;AAEtB,MAAOC,CAAAA,cAAP,CACD,CACD,cAAeH,CAAAA,WAAf","sourcesContent":["import { useState, useEffect } from \"react\";\r\n\r\nfunction useOnScreen(ref, threshold = 0.3) {\r\n  // State and setter for storing whether element is visible\r\n  const [isIntersecting, setIntersecting] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const observer = new IntersectionObserver(\r\n      ([entry]) => {\r\n        // Update our state when observer callback fires\r\n        setIntersecting(entry?.isIntersecting ?? false);\r\n      },\r\n      {\r\n        rootMargin: \"0px\",\r\n        threshold,\r\n      }\r\n    );\r\n    const currentRef = ref.current;\r\n    if (currentRef) {\r\n      observer.observe(currentRef);\r\n    }\r\n    return () => {\r\n      if (currentRef) {\r\n        observer.unobserve(currentRef);\r\n      }\r\n    };\r\n  }, [ref, threshold]); // Empty array ensures that effect is only run on mount and unmount\r\n\r\n  return isIntersecting;\r\n}\r\nexport default useOnScreen;"]},"metadata":{},"sourceType":"module"}