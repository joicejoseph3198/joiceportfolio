{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from \"react\";\n\nfunction useOnScreen(ref, threshold = 0.3) {\n  _s();\n\n  // State and setter for storing whether element is visible\n  const [isIntersecting, setIntersecting] = useState(false);\n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]) => {\n      var _entry$isIntersecting;\n\n      // Update our state when observer callback fires\n      setIntersecting((_entry$isIntersecting = entry === null || entry === void 0 ? void 0 : entry.isIntersecting) !== null && _entry$isIntersecting !== void 0 ? _entry$isIntersecting : false);\n    }, {\n      rootMargin: \"0px\",\n      threshold\n    });\n    const currentRef = ref.current;\n\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [ref, threshold]); // Empty array ensures that effect is only run on mount and unmount\n\n  return isIntersecting;\n}\n\n_s(useOnScreen, \"+TWZGT8mxcpNH+JS7IkSFv1hR0A=\");\n\nexport default useOnScreen;","map":{"version":3,"sources":["H:/Web Dev/React Learning/web-1/src/components/hooks/useOnScreen.js"],"names":["useState","useEffect","useOnScreen","ref","threshold","isIntersecting","setIntersecting","observer","IntersectionObserver","entry","rootMargin","currentRef","current","observe","unobserve"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;;AAEA,SAASC,WAAT,CAAqBC,GAArB,EAA0BC,SAAS,GAAG,GAAtC,EAA2C;AAAA;;AACzC;AACA,QAAM,CAACC,cAAD,EAAiBC,eAAjB,IAAoCN,QAAQ,CAAC,KAAD,CAAlD;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMM,QAAQ,GAAG,IAAIC,oBAAJ,CACf,CAAC,CAACC,KAAD,CAAD,KAAa;AAAA;;AACX;AACAH,MAAAA,eAAe,0BAACG,KAAD,aAACA,KAAD,uBAACA,KAAK,CAAEJ,cAAR,yEAA0B,KAA1B,CAAf;AACD,KAJc,EAKf;AACEK,MAAAA,UAAU,EAAE,KADd;AAEEN,MAAAA;AAFF,KALe,CAAjB;AAUA,UAAMO,UAAU,GAAGR,GAAG,CAACS,OAAvB;;AACA,QAAID,UAAJ,EAAgB;AACdJ,MAAAA,QAAQ,CAACM,OAAT,CAAiBF,UAAjB;AACD;;AACD,WAAO,MAAM;AACX,UAAIA,UAAJ,EAAgB;AACdJ,QAAAA,QAAQ,CAACO,SAAT,CAAmBH,UAAnB;AACD;AACF,KAJD;AAKD,GApBQ,EAoBN,CAACR,GAAD,EAAMC,SAAN,CApBM,CAAT,CAJyC,CAwBnB;;AAEtB,SAAOC,cAAP;AACD;;GA3BQH,W;;AA4BT,eAAeA,WAAf","sourcesContent":["import { useState, useEffect } from \"react\";\r\n\r\nfunction useOnScreen(ref, threshold = 0.3) {\r\n  // State and setter for storing whether element is visible\r\n  const [isIntersecting, setIntersecting] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const observer = new IntersectionObserver(\r\n      ([entry]) => {\r\n        // Update our state when observer callback fires\r\n        setIntersecting(entry?.isIntersecting ?? false);\r\n      },\r\n      {\r\n        rootMargin: \"0px\",\r\n        threshold,\r\n      }\r\n    );\r\n    const currentRef = ref.current;\r\n    if (currentRef) {\r\n      observer.observe(currentRef);\r\n    }\r\n    return () => {\r\n      if (currentRef) {\r\n        observer.unobserve(currentRef);\r\n      }\r\n    };\r\n  }, [ref, threshold]); // Empty array ensures that effect is only run on mount and unmount\r\n\r\n  return isIntersecting;\r\n}\r\nexport default useOnScreen;"]},"metadata":{},"sourceType":"module"}